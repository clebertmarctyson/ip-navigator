import * as validation from "./validation";
import * as conversion from "./conversion";
import * as subnet from "./subnet";
import * as operation from "./operation";
export { validation, conversion, subnet, operation };
export * from "./validation";
export * from "./conversion";
export * from "./subnet";
export * from "./operation";
declare const ipNavigator: {
    getNextIPAddress: (ipAddress: string) => string;
    getPreviousIPAddress: (ipAddress: string) => string;
    isIPAddressInSubnet: (ipAddress: string, networkAddress: string, subnetMask: string) => boolean;
    isPublicIP: (ipAddress: string) => boolean;
    isPrivateIP: (ipAddress: string) => boolean;
    getIPRange: (startIP: string, endIP: string) => string[];
    compareIPAddresses: (ip1: string, ip2: string) => -1 | 0 | 1;
    calculateNetworkAddress: (ipAddress: string, subnetMask: string) => string;
    calculateBroadcastAddress: (ipAddress: string, subnetMask: string) => string;
    calculateAvailableIPs: (networkAddress: string, subnetMask: string) => string[];
    getSubnetInfo: (ipAddress: string, subnetMask: string) => {
        networkAddress: string;
        broadcastAddress: string;
        totalHosts: number;
        usableHosts: number;
        firstUsableHost: string;
        lastUsableHost: string;
    };
    ipToBinary: (ipAddress: string) => string;
    binaryToIP: (binaryIP: string) => string;
    ipToInteger: (ipAddress: string) => number;
    integerToIP: (integer: number) => string;
    cidrToSubnetMask: (prefix: number) => string;
    subnetMaskToCIDR: (subnetMask: string) => number;
    isValidIPAddress: (ipAddress: string) => boolean;
    isValidSubnetMask: (subnetMask: string) => boolean;
    isValidCIDR: (cidr: string) => boolean;
    isValidBinaryIP: (binaryIP: string) => boolean;
};
export default ipNavigator;
